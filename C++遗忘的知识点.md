C++遗忘的知识点
### 1.为什么在类内部实现的函数都是内联函数
### 2.关于运算符重载为友元函数有如下规定：①一般情况下，单目运算符最好重载为类的成员函数，双目运算符则最好重载为类的友元函数；②双目运算符“=、（）、［］、->”不能重载为类的友元函数。故本题答案是= () [ ] ->。
**因为它们与this指针都有太多关联**
[运算符的重载规则](https://cloud.tencent.com/developer/article/1176389)

### 3.为了取消C中的带参宏，可使用内联函数，内联函数是使用函数体来替换函数调用表达式，类似于宏。
### 4.变量的存储方法分为静态存储和动态存储两大类，包含4种：自动的(auto)、静态的(static)、寄存器的(register)、外部的(extern)。变量如果没有说明存储类型，那么默认就是auto。故本题答案是auto。
**为什么auto也是一种存储类型？**
### 5. 前缀`++`运算符和后缀`--`运算符在重载时形参列表差一个int
### 6.重载运算符的函数不能含默认值。**为啥？**
### 7.函数模板
### 8.如果已经定义了复制运算符，还能能重载赋值运算符
**想一想在main函数中虽然你为一个类对象A赋了初值，这时如果你想将一个本类对象B的值拷贝到A中，如果你没有重载赋值运算符应该会编译出错。**
### 9.运算符重载函数为什么不能含默认值 [运算符重载函数为什么不能含默认值](https://bbs.csdn.net/topics/300219759)
### 10. 在类体中定义的成员函数，C++系统会自动将它们作为内联函数处理，而在类外定义的成员函数，系统并不把它们默认为内联函数，内联函数可以用return，也可以不用。
### 11. extern可以置于变量或者函数前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。在c++语言中 auto 被解释为一个自动存储变量的关键字，也就是申明一块临时的变量内存。register修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度。在变量前，加上关键字static，该变量就被定义成为一个静态变量,该变量在全局数据区分配内存。
### 12.派生类构造函数中需不需要显示地调用基类构造函数
### 13. （1）如果没有定义复制构造函数，编译器会生成一个复制构造函数；（2）一个类如果定义了任何一个构造函数，编译器都不会再生成默认构造函数；（3）如果没有定义构造函数，编译器会生成一个默认的构造函数和一个复制构造函数；（4）如果定义了构造函数和复制构造函数，编译器不会生成任何构造函数。
### 14.类的静态数据成员可以为常成员
### 15. 类定义中不能包含自己本身的对象,否则会引起无限递归的问题，结果就是内存被消耗殆尽。
### 16. 调用函数模板的特殊情况：
```
#include<iostream>
using std::cout;
using std::endl;

template <typename T, typename U>
T cast(U u) { return u;}

int main()
{
	int i = 3;
	cout<<sizeof(int)<<endl;
	cout<<sizeof(cast <double, int>(i))<<endl;

    return 0;
}
```
<font color=green>理解不了</font>
### 17.在调用一个模板函数时，编译系统需要足够的信息来判别每个虚拟类型参数所对应的实际类型，可以从两个不同的渠道获得这样的信息：从模板实参表(用“< >”括起来的参数表)或从模板函数实参表(用“()”括起来的参数表)。如果从后者获得的信息已经能够判定其中部分或全部虚拟类型参数所对应的实际参数，而且它们又正好是参数表中最后的若干参数，则模板实参表中的那几个参数可以省略。如果模板实参表中的实参都被省略了，则空表“< >”也可以不要，因此选项D错误。反之，对于某个模板实参，如果从模板函数的实参表中无法获得同样的信息，就不能省略；或者虽然能够获得同样的信息，但在它后面还有其他不能省略的实参，则其自身还是不能省略。
### 18.
```
#include<iostream>
using std::cin;
using std::endl;
using std::cout;


int main()
{
	char str[10];
	cin>>str;
	cout<<str<<endl;
    return 0;
}
```
当使用cin输入时，程序中的变量从">>"流中提取字符，遇到空格、换行、Tab时提取结束。

### 19. 
```
class A{
	static int a;
	public:
		int init(){
		a = 10;
	}
	A(int a){
		init(); a+=10;
	}

}
static int A::a = 0;
```
静态数据成员独立于任何对象而存在，不是类对象的组成部分，普通成员函数可以引用静态数据成员。程序定义了类A，并在A的定义体外初始化A的静态数据成员a=0，构造函数A(int)中的形参a与A::a属于不同的变量，在函数A(int)中，形参a屏蔽了A::a，所以A(int)中引用的变量a是形参，而不是A::a，对a的任何操作都不影响A::a，而成员函数init中引用的是A::a，语句a=10是将A::a赋值为10，所以输出obj.a其实是输出A::a，结果为10